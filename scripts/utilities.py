"""This script contains utility functions used throughout the codebase."""
import numpy as np

from scripts.proj1_helpers import predict_labels


def compute_f1score(w, x, y_true):
    """
    Compute the F1 score.

    :param w: Model weights.
    :param x: Input features.
    :param y_true: Ground truth labels.
    :return: F1 score.
    """
    y_pred = predict_labels(w, x)
    recall, precision, accuracy = calculate_recall_precision_accuracy(create_confusion_matrix(y_pred, y_true))

    return 2*(precision*recall)/(precision+recall)


def matthews_coeff(w, x, y_true, _y_pred):
    """
    Compute the Matthews coefficient.

    :param w: Model weights.
    :param x: Input features.
    :param y_true: Ground truth labels.
    :param _y_pred: Predicted labels.
    :return: Matthews coefficient.
    """
    if w is not None:
        y_pred = predict_labels(w, x)
    else:
        y_pred = _y_pred
    cm = create_confusion_matrix(y_pred, y_true)
    tn, tp, fp, fn = cm[0, 0], cm[1, 1], cm[1, 0], cm[0, 1]
    mc = (tp * tn - fp * fn) / np.sqrt((tp + fp) * (tp + fn) * (tn + fp) * (tn + fn))

    return mc


def create_confusion_matrix(predicted, actual):
    """
    Generate confusion matrix.

    :param predicted: Predicted values.
    :param actual: Ground truth values.
    :return: Confusion matrix.
    """
    cm = np.zeros((2, 2), dtype=np.int)
    for i in range(len(predicted)):
        if actual[i] == -1 and predicted[i] == -1:
            cm[0, 0] += 1
        if actual[i] == -1 and not predicted[i] == -1:
            cm[1, 0] += 1
        if actual[i] == 1 and not predicted[i] == 1:
            cm[0, 1] += 1
        if actual[i] == 1 and predicted[i] == 1:
            cm[1, 1] += 1
    return cm


def calculate_recall_precision_accuracy(confusion_matrix: np.ndarray):
    """
    Compute recall, precision, and accuracy.

    :param confusion_matrix: Confusion matrix as generated by the create_confusion_matrix() function.
    :return: Recall, precision, and accuracy metrics.
    """
    cm = confusion_matrix
    recall = cm[1, 1] / (cm[1, 1] + cm[0, 1])
    precision = cm[1, 1] / (cm[1, 1] + cm[1, 0])
    accuracy = (cm[0, 0] + cm[1, 1]) / np.sum(cm)
    return recall, precision, accuracy


def obtain_best_params(accuracy_ranking, gammas, degrees, lambdas):
    """
    Based on the accuracy rankings generated in the hyperparameter tuning scripts, the array can be passed with the
    corresponding hyperparameters and it will return the value pertaining to the highest accuracy. Set None as input if
    that specific run did not contain a given hyperparameter.

    :param accuracy_ranking: Array containing accuracy values pertaining to different combinations of hyperparameters.
    :param gammas: List containing tested gamma values.
    :param degrees: List containing tested degree values.
    :param lambdas: List containing tested lambda values.
    :return: Corresponding values for the hyperparameters.
    """
    max_ind = np.unravel_index(np.argmax(accuracy_ranking), accuracy_ranking.shape)

    degree_ind = max_ind[1]
    degree = degrees[degree_ind]

    if gammas is not None and lambdas is not None:
        gamma_ind = max_ind[0]
        gamma = gammas[gamma_ind]

        lambda_ind = max_ind[2]
        lambda_ = lambdas[lambda_ind]

        return gamma, degree, lambda_

    elif gammas is not None and lambdas is None:
        gamma_ind = max_ind[0]
        gamma = gammas[gamma_ind]

        return gamma, degree

    elif gammas is None and lambdas is not None:
        lambda_ind = max_ind[0]
        lambda_ = lambdas[lambda_ind]

        return degree, lambda_

    else:
        return degree
